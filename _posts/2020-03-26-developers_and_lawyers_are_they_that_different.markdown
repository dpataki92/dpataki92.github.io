---
layout: post
title:      "Developers and Lawyers: Are They That Different?"
date:       2020-03-26 03:06:51 -0400
permalink:  developers_and_lawyers_are_they_that_different
---


![](https://images.law.com/contrib/content/uploads/sites/402/2020/02/Legal-Technology-Article-202002031616.jpg)

During my three-year-long legal career, I met a surprisingly high number of lawyers who, at some point in their careers, started to play with the idea of learning how to code. The reasons why they found coding interesting varied but the reason why they didn’t eventually take this path was almost always the same. They convinced themselves that practicing law is fundamentally different from programming when it comes to skills. One is about math and numbers and the other is about writing abilities. 

I started studying web development last year, alongside my job for a while and then full time. Over time, it became increasingly clear to me that the above idea is a false belief and that legal thinking is not that far from development. For some reason, many lawyers still consider the legal profession as one defined by factual knowledge and communication skills. They underestimate or forget about logic, analytical problem-solving, structural thinking and the ability to work with abstractions and dependencies as if they don’t form an integral part of legal practice. At the same time, in my opinion, these are the top skills that characterize a good lawyer, just as they describe a good developer.

In his great book, the *Legal Writing In Plain English*, Bryan A. Garner provides one of the simplest, and yet most powerful ideas of what stages should characterize high-quality legal writing. According to Garner, four different personas should work on each legal document, one after the other, separately, building on the work of the previous one but without taking over anyone’s job. The four personas are the *madman*, the *architect*, the *carpenter*, and the *judge*.

Simply put, in legal writing it means that (i) the *Madman* thinks of the things you want to say, as many and as quickly as possible (ii) the *Architect* sets up a logical sequence of these thoughts and breaks them down into smaller thoughts (iii) the *Carpenter* prepares the draft based on the above (iv) finally, the *Judge* returns and edits the draft after a while. In my view, *this problem-solving process is basically the same as what coding schools or tech books and articles teach us about addressing coding issues*. 

For me, the **Madman** is the one who identifies and lays out separable goals that the program wants to accomplish through various functions/methods. Ask the user what kind of product he wants to buy and how much, check if the product is available, calculate the total price to be paid, inform the user of the purchase status and so on. For me, these are the first, high-level lines of a pseudo code in a program that describe the operation of the functions in 1-2 sentences. In a more complex program - following the test-driven development approach – these can be the tests that briefly summarize the operation of the function and determine the desired result.

The **Architect** breaks down the identified problems into smaller sub-problems. In the context of coding, I think this is the phase when we are already inside the function and we write our pseudo code to describe the specific steps of that function. Loop through the object containing the items and their available quantity, if the value of the item (key) is greater than or equal with the user’s input, calculate the price, if not, inform the customer that the item is unavailable and so on. At this point, we still don't code. We only clarify the exact operation of the functions that are required to achieve the desired goal. Like the lawyer who organizes his thoughts into logical groupings and outlines the main ideas within those bigger points based on the previous sketch.

The **Carpenter** is the one who writes the code. Based on the architect's work, the carpenter translates the human language into a programming language. For me, this is when we declare the variables and functions, write the loops, set up the if-else statements and so on. At this stage, we are still not striving for perfection, we are not letting the judge appear too soon and urge us to spend too much time on each line wondering how to make it shorter or more efficient. We just translate each specific step into code so that the program passes our tests and accomplishes the desired goals. It is the same process when the lawyer drafts and translates ideas into the language of the law. As Garner says, this phase must feel like filling in the blanks.

The **Judge** comes in last place. For me, this is refactoring in development. This is the phase when we review and improve the code with a clear head to make it as readable, logical and simple as possible. This is when the if-else statement becomes a ternary operator, when we use an iterator instead of an unnecessarily long loop or when we delete a few redundant return keywords based on the implicit return functionality in Ruby. Just as the lawyer’s client or colleague does not want to wade through an overly complicated, lengthy legal prose, we also try to replace all the complicated, expansive code with simpler, shorter, easy-to-understand syntax.

And what are the most important skills that a developer needs to have during this process? The same that a lawyer needs to use when writing a legal document. 
* *Attention to details* - Just like a missed "not" or an extra zero in a contract, an unnecessary or missing comma can cause many problems in the program. 
* *Research skills* – Using internal and external resources, finding answers, interpreting precedents, and applying them effectively to your specific problem.
* *Logical and structured writing* - A good legal document consists of successive sections free of logical inconsistency and it pays attention to dependencies. If necessary, it sets up scenarios and handles alternative outcomes. As I see, it is no different in programming. 
* *Writing in a formalized language* - Both activities rely on a formalized language that is somewhat bound by its own rules. Like the code, a contract reuses terms (variables) throughout the document and, preferably, does not duplicate itself (DRY), while it is as simple as possible. Also, there are probably several versions before the final product, on which different colleagues work, yet it must be unified and free of contradictions (version control).

Does it mean that all lawyers who are interested in technology should quit their jobs and be developers? Or that every aspect of the two fields is that similar? Absolutely not. I just argue that the gap is not that big and there is a huge overlap between the applied problem-solving approaches and the skills you need in both professions. And I’m sure it is true for other areas as well. I think that coming from a field of humanities does not mean that you are bad in analytical thinking and logic.

I chose to take this path because I think coding (or at least web development) is way more about creativity and logical thinking than math. It is science but also feels like art sometimes. I hope that more and more lawyers will feel the same way. I see plenty of existing and future opportunities for innovation in the legal market that needs to be led at least partly by people who have experience in both areas. And this is not only true for the legal market. We often hear that every company is a tech company, which I think is very true. And technology will probably reshape other areas as well that are – similarly to the legal profession – were traditionally slow-moving with innovation, enabling many people to seek opportunities to combine their first profession and their second.



